\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; Даны два массива ArrayA, ArrayB, состоящие из 10 элементов каждый; Сравнить эти массивы поэлементно и \PYGZhy{} если элементы равны, то записать в соответствующий элемент третьего массива (Difference) \PYGZsq{}Y\PYGZsq{} \PYGZhy{} иначе \PYGZsq{}N\PYGZsq{} Найти сумму и количество всех одинаковых и различных элементов двух массивов (ArrayA,ArrayB)}
\PYG{n+no}{.model}\PYG{k+kd}{ tiny}
\PYG{n+nf}{.stack} \PYG{l+m+mh}{100h}
\PYG{n+nf}{.data}
\PYG{n+no}{ArrayA}\PYG{k+kd}{ db} \PYG{l+m+mi}{05}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{06}\PYG{p}{,}\PYG{l+m+mi}{44}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{05}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{46}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{n+no}{ArrayB}\PYG{k+kd}{ db} \PYG{l+m+mi}{35}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{44}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{02}\PYG{p}{,}\PYG{l+m+mi}{65}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{46}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{n+no}{Difference}\PYG{k+kd}{ db} \PYG{l+m+mi}{10} \PYG{n+nv}{dup}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+no}{NumOfDiff}\PYG{k+kd}{ dw} \PYG{l+m+mi}{0}
\PYG{n+no}{NumOfEqual}\PYG{k+kd}{ dw} \PYG{l+m+mi}{0}
\PYG{n+nf}{.code}
\PYG{n+nl}{start:}
\PYG{n+nf}{mov} \PYG{n+nb}{ax}\PYG{p}{,}\PYG{n+nv}{@data} \PYG{c+c1}{; ax ArrayA \PYGZhy{} 000h в регистре адрес начала массива}
\PYG{n+nf}{mov} \PYG{n+nb}{ds}\PYG{p}{,}\PYG{n+nb}{ax} \PYG{c+c1}{; ds (data segment) ArrayA \PYGZhy{} 000h адрес начала массива}
\PYG{n+nf}{push} \PYG{n+nb}{ds} \PYG{c+c1}{; ArrayA , SP: 000h помещаем адрес на стек}
\PYG{n+nf}{pop} \PYG{n+nb}{es} \PYG{c+c1}{; ArrayA ES, ES: 000h извлекаем адрес из стека и помещаем в}
\PYG{n+nf}{mov} \PYG{n+nb}{di}\PYG{p}{,}\PYG{n+nv}{offset} \PYG{n+nb}{Di}\PYG{n+nv}{fference} \PYG{c+c1}{; DI: 014h}
\PYG{n+nf}{mov} \PYG{n+nb}{cx}\PYG{p}{,}\PYG{l+m+mi}{10} \PYG{c+c1}{; CX: 10}
\PYG{n+nf}{mov} \PYG{n+nb}{al}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}Y\PYGZsq{}} \PYG{c+c1}{; al : \PYGZsq{}Y\PYGZsq{}}
\PYG{n+nf}{cld} \PYG{c+c1}{; Clears the DF flag in the EFLAGS register \PYGZhy{} DF: 0}
\PYG{n+nf}{rep} \PYG{n+nv}{stosb} \PYG{c+c1}{; store contents of AL into memory address pointed by ES:DI}
\PYG{n+nf}{mov} \PYG{n+nb}{si}\PYG{p}{,}\PYG{n+nv}{offset} \PYG{n+nv}{ArrayA} \PYG{c+c1}{; si: 000h}
\PYG{n+nf}{mov} \PYG{n+nb}{di}\PYG{p}{,}\PYG{n+nv}{offset} \PYG{n+nv}{ArrayB} \PYG{c+c1}{; di: 00Ah}
\PYG{n+nf}{mov} \PYG{n+nb}{bx}\PYG{p}{,}\PYG{n+nv}{offset} \PYG{n+nb}{Di}\PYG{n+nv}{fference} \PYG{c+c1}{; bx: 014h}
\PYG{n+nf}{mov} \PYG{n+nb}{cx}\PYG{p}{,}\PYG{l+m+mi}{10} \PYG{c+c1}{; cx: 10 — loop count (used by loop instruction)}
\PYG{n+nf}{cld} \PYG{c+c1}{; DF: 0}
\PYG{n+nl}{findDE:}
\PYG{n+nf}{cmpsb} \PYG{c+c1}{; ECX: 1, SI: 001h, di: 00Bh (compares DS:SI to ES:DI)}
\PYG{c+c1}{; second iteration: SI: 002h, di: 00Ch}
\PYG{n+nf}{jne} \PYG{n+nv}{NotEqual} \PYG{c+c1}{; IP: [NotEqual]}
\PYG{c+c1}{;second iteration: IP: [IP +1]}
\PYG{n+nf}{inc} \PYG{n+nv}{NumOfEqual}
\PYG{n+nf}{inc} \PYG{n+nb}{bx} \PYG{c+c1}{; bx: 016h}
\PYG{n+nf}{dec} \PYG{n+nb}{di} \PYG{c+c1}{; di: 00Bh}
\PYG{n+nf}{dec} \PYG{n+nb}{si} \PYG{c+c1}{; si: 001h}
\PYG{n+nf}{mov} \PYG{n+nb}{al}\PYG{p}{,}\PYG{k+kt}{byte} \PYG{n+nv}{ptr} \PYG{n+nb}{ds}\PYG{p}{:[}\PYG{n+nb}{si}\PYG{p}{]} \PYG{c+c1}{; al: 00Ah ( 1010 )}
\PYG{n+nf}{cbw} \PYG{c+c1}{;ah: 00Ah — sign extension AL AH (value and sign remain same) →}
\PYG{n+nf}{add} \PYG{n+nv}{SumOfEqual}\PYG{p}{,} \PYG{n+nb}{ax}
\PYG{n+nf}{mov} \PYG{n+nb}{al}\PYG{p}{,}\PYG{k+kt}{byte} \PYG{n+nv}{ptr} \PYG{n+nb}{ds}\PYG{p}{:[}\PYG{n+nb}{di}\PYG{p}{]} \PYG{c+c1}{; al: 00Ah ( 1010 )}
\PYG{n+nf}{cbw} \PYG{c+c1}{;ah: 00Ah — sign extension AL AH (value and sign remain same) →}
\PYG{n+nf}{add} \PYG{n+nv}{SumOfEqual}\PYG{p}{,} \PYG{n+nb}{ax}
\PYG{n+nf}{inc} \PYG{n+nb}{si} \PYG{c+c1}{; si: 002h}
\PYG{n+nf}{inc} \PYG{n+nb}{di} \PYG{c+c1}{; di: 00Ch}
\PYG{n+nf}{jmp} \PYG{n+nv}{NextElement} \PYG{c+c1}{; IP: [NextElement]}
\PYG{n+nl}{NotEqual:}
\PYG{n+nf}{inc} \PYG{n+nv}{NumOfDiff}
\PYG{n+nf}{mov} \PYG{k+kt}{byte} \PYG{n+nv}{ptr} \PYG{n+nb}{ds}\PYG{p}{:[}\PYG{n+nb}{bx}\PYG{p}{],}\PYG{l+s}{\PYGZsq{}N\PYGZsq{}}
\PYG{n+nf}{inc} \PYG{n+nb}{bx} \PYG{c+c1}{; bx: 015h}
\PYG{n+nf}{dec} \PYG{n+nb}{di} \PYG{c+c1}{; di: 00Ah}
\PYG{n+nf}{dec} \PYG{n+nb}{si} \PYG{c+c1}{; si: 000h}
\PYG{n+nf}{mov} \PYG{n+nb}{al}\PYG{p}{,}\PYG{k+kt}{byte} \PYG{n+nv}{ptr} \PYG{n+nb}{ds}\PYG{p}{:[}\PYG{n+nb}{si}\PYG{p}{]} \PYG{c+c1}{; al: 005h ( 510 )}
\PYG{n+nf}{cbw} \PYG{c+c1}{; ah: 05 — sign extension AL AH (value and sign remain same) →}
\PYG{n+nf}{add} \PYG{n+nv}{SumOfDiff}\PYG{p}{,} \PYG{n+nb}{ax}
\PYG{n+nf}{mov} \PYG{n+nb}{al}\PYG{p}{,}\PYG{k+kt}{byte} \PYG{n+nv}{ptr} \PYG{n+nb}{ds}\PYG{p}{:[}\PYG{n+nb}{di}\PYG{p}{]} \PYG{c+c1}{; al: 023h ( 3510 )}
\PYG{n+nf}{cbw} \PYG{c+c1}{; ah: 023h}
\PYG{n+nf}{add} \PYG{n+nv}{SumOfDiff}\PYG{p}{,} \PYG{n+nb}{ax}
\PYG{n+nf}{inc} \PYG{n+nb}{si} \PYG{c+c1}{; si: 001h}
\PYG{n+nf}{inc} \PYG{n+nb}{di} \PYG{c+c1}{; di: 00Bh}
\PYG{n+nl}{NextElement:}
\PYG{n+nf}{loop} \PYG{n+nv}{findDE} \PYG{c+c1}{; cx: 9}
\PYG{n+nf}{mov} \PYG{n+nb}{ax}\PYG{p}{,}\PYG{l+m+mh}{4c00h} \PYG{c+c1}{; ax: 4c00h}
\PYG{n+nf}{int} \PYG{l+m+mh}{21h}
\PYG{k}{end} \PYG{n+nv}{start}
\end{Verbatim}
